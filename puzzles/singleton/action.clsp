; action.clsp by yakuhito
;; Inner puzzle for a singleton that has a state and may run any of n actions
;; Each action will receive the current state + an ephemeral state and return new values
;; One or more actions may be run per spend

;; An action's solution will always be: (list (Ephemeral_State . Current_State) solution)
;;    (where capital first letters are used to denote Truths)
;; It returns three values: ((new_ephemeral_state . new_state) . new_conditions)
;;    state is passed from one action to the next and the latest value is saved between spends
;;        (it is persistent)
;;    ephemeral_state is not persistent - it's () for the first action of any new spend
;;        but passed from the previous action in the same spend
;;    new_conditions will be directly added to this puzzle's output conditions
;;    but the finalizer puzzle is able to filter them after all actions are run

;; The 'puzzles' parameter is a list of action puzzles - it's intended to allow an action to 
;;   be run multiple times while its puzzle is only revealed and hashed once. This is done via
;;   selectors - programs that, given 'puzzles' as a solution, return a puzzle. These selectors
;;   are numbers (e.g., the '2' program returns (f puzzles)).
;; 'partial_tree_reveal' is, as the name suggests, a partial reveal of the Merkle tree - it
;;   contains partial hashes or atoms that look like (() . selector) for leaves that correspond
;;   to puzzle hashes that are run (so their inclusion can be confirmed). The parsing process of
;;   the tree produces two outputs: a Merkle root (validated against MERKLE_ROOT) and a list of
;;   allowed selectors.

;; Warning: This puzzle's finalizer likely assumes the singleton's amount is 1 (like the default one does).

(mod (
    FINALZIER
    MERKLE_ROOT
    STATE
    puzzles
    partial_tree_reveal ; tree reveal
    selectors_and_solutions ; (list (selector . action_solution) ...)
    finalizer_solution
)
    (include sha256tree.clib)

    (defun item_in_list (the_item (@ the_list (first_item . remaining_list)))
        (if (= the_item first_item)
            1
            (item_in_list the_item remaining_list)
        )
    )

    ; add items of list b to the beginning of list b
    (defun merge_list (list_a list_b)
        (if list_a
            (c (f list_a) (merge_list (r list_a) list_b))
            list_b
        )
    )

    (defun-inline hash_branches_and_merge_results ((selectors1 . tree1) (selectors2 . tree2))
        (c
            (merge_list selectors1 selectors2)
            (sha256 2 tree1 tree2)
        )
    )

    (defun handle_branch (puzzles selectors_and_branch)
        (if (l branch)
            (consume_tree puzzles selectors_and_branch)
            ; else - branch just a hash
            selectors_and_branch
        )
    )

    ; returns (selectors . merkle_root)
    (defun consume_tree (
        puzzles
        (@ selectors_and_tree (selectors_so_far left_branch . right_branch))
    )
        (if left_branch
            (hash_branches_and_merge_results
                (handle_branch puzzles (c left_branch ()))
                (handle_branch puzzles (c selectors_so_far right_branch))
            )
            ; else - this is a reveal; selector = (r tree) = right_branch
            (c 
                (c right_branch selectors_so_far)
                (sha256 1 (sha256tree (a right_branch puzzles)))
            )
        )
    )

    (defun run_actions (
        puzzles
        current_conditions
        (ephemeral_and_actual_state . new_conditions)
        selector_whitelist
        (@ pending_selectors_and_solutions ((selector . solution) . remaining_pending_selectors_and_solutions))
    )
        (if remaining_pending_selectors_and_solutions
            (if (item_in_list selector selector_whitelist)
                (run_actions
                    puzzles
                    (c new_conditions current_conditions)
                    (a (a selector puzzles) (list ephemeral_and_actual_state solution))
                    selector_whitelist
                    remaining_pending_selectors_and_solutions
                )
                ; else
                (x)
            )
            ; else
            (c
                ephemeral_and_actual_state
                (c new_conditions current_conditions)
            )
        )
    )

    (defun assert_merkle_root_and_return_selectors (merkle_root (selector_whitelist . calculated_root))
        (if (= merkle_root calculated_root)
            selector_whitelist
            ; else
            (x)
        )
    )
    
    (a
        FINALZIER
        (list
            MERKLE_ROOT
            STATE
            (run_actions
                puzzles                
                ()
                (list (c () STATE))
                (assert_merkle_root_and_return_selectors MERKLE_ROOT (consume_tree puzzles (c () partial_tree_reveal)))
                selectors_and_solutions
            )
            finalizer_solution
        )
    )
)
